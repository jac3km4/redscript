use std::io;
use std::ops::Deref;

use redscript::ast::{Constant, Expr, Ident, LiteralType, Pos, Seq, SwitchCase, Target, TypeName};
use redscript::bundle::{ConstantPool, PoolIndex};
use redscript::bytecode::{CodeCursor, Instr, Offset, Position};
use redscript::error::Error;

pub mod print;

pub struct Decompiler<'a> {
    code: &'a mut CodeCursor<'a>,
    pool: &'a ConstantPool,
}

impl<'a> Decompiler<'a> {
    pub fn new(code: &'a mut CodeCursor<'a>, pool: &'a ConstantPool) -> Decompiler<'a> {
        Decompiler { code, pool }
    }

    pub fn decompile(&mut self) -> Result<Seq, Error> {
        self.consume_path(Position::MAX)
    }

    fn definition_ident<A>(&self, index: PoolIndex<A>) -> Result<Ident, Error> {
        Ok(Ident(self.pool.definition_name(index)?))
    }

    fn consume_n(&mut self, n: usize) -> Result<Vec<Expr>, Error> {
        let mut body = Vec::new();
        for _ in 0..n {
            body.push(self.consume()?)
        }
        Ok(body)
    }

    fn consume_path(&mut self, target: Position) -> Result<Seq, Error> {
        let mut body = Vec::new();
        loop {
            if self.code.pos() >= target
                || matches!(body.last(), Some(Expr::Goto(_, _)))
                || matches!(body.last(), Some(Expr::Return(_, _)))
            {
                break;
            }
            match self.consume() {
                Ok(expr) => body.push(expr),
                Err(Error::IOError(err)) if err.kind() == io::ErrorKind::UnexpectedEof => break,
                Err(err) => Err(err)?,
            }
        }
        Ok(Seq::new(body))
    }

    fn consume_call(&mut self, name: &str, param_count: usize) -> Result<Expr, Error> {
        let params = self.consume_n(param_count)?;
        Ok(Expr::Call(Ident::new(name.to_owned()), params, Pos::ZERO))
    }

    fn consume_params(&mut self) -> Result<Vec<Expr>, Error> {
        let mut params = Vec::new();
        loop {
            while matches!(self.code.peek(), Some(Instr::Skip(_))) || matches!(self.code.peek(), Some(Instr::Nop)) {
                self.code.pop()?;
            }
            if matches!(self.code.peek(), Some(Instr::ParamEnd)) {
                break;
            }
            params.push(self.consume()?);
        }
        self.code.pop()?;
        Ok(params)
    }

    fn consume_conditional_jump(&mut self, position: Position, offset: Offset) -> Result<Expr, Error> {
        let condition = self.consume()?;
        let target = offset.absolute(position);
        let mut body = self.consume_path(target)?;
        self.code.goto(target)?;

        let result = if let Some(_) = resolve_jump(&mut body, Some(position)) {
            Expr::While(Box::new(condition), body)
        } else if let Some(jump) = resolve_jump(&mut body, None) {
            let else_case = self.consume_path(Position::new(jump.position))?;
            Expr::If(Box::new(condition), body, Some(else_case))
        } else {
            Expr::If(Box::new(condition), body, None)
        };
        Ok(result)
    }

    fn consume_switch(&mut self) -> Result<Expr, Error> {
        let subject = self.consume()?;

        let mut labels = Vec::new();
        while let Some(Instr::SwitchLabel(exit_offset, start_offset)) = self.code.peek() {
            let position = self.code.pos();
            labels.push((position, start_offset.absolute(position)));
            self.code.seek(exit_offset.into())?;
        }
        if let Some(Instr::SwitchDefault) = self.code.peek() {
            labels.push((self.code.pos(), self.code.pos()));
        };
        labels.sort_by_key(|(_, start)| *start);

        let mut default = None;
        let mut cases = Vec::new();
        for (label, start_position) in labels {
            self.code.goto(label.into())?;

            match self.code.pop()? {
                Instr::SwitchLabel(exit_offset, _) => {
                    let exit = exit_offset.absolute(label);
                    let matched = self.consume()?;

                    self.code.goto(start_position)?;
                    let mut body = self.consume_path(exit)?;
                    if let Some(Expr::Goto(_, _)) = body.exprs.last() {
                        body.exprs.pop();
                        body.exprs.push(Expr::Break);
                    }
                    cases.push(SwitchCase(matched, body));
                }
                Instr::SwitchDefault => default = Some(Seq::new(vec![self.consume()?])),
                _ => Err(Error::DecompileError("Unexpected switch label instruction".to_owned()))?,
            }
        }

        Ok(Expr::Switch(Box::new(subject), cases, default))
    }

    fn consume(&mut self) -> Result<Expr, Error> {
        self.consume_with(None)
    }

    fn consume_with(&mut self, context: Option<Expr>) -> Result<Expr, Error> {
        let position = self.code.pos();
        let res = match self.code.pop()? {
            Instr::Nop => Expr::EMPTY,
            Instr::Null => Expr::Null,
            Instr::I32One => Expr::Constant(Constant::Int(1), Pos::ZERO),
            Instr::I32Zero => Expr::Constant(Constant::Int(0), Pos::ZERO),
            Instr::I8Const(val) => Expr::Constant(Constant::Int(val.into()), Pos::ZERO),
            Instr::I16Const(val) => Expr::Constant(Constant::Int(val.into()), Pos::ZERO),
            Instr::I32Const(val) => Expr::Constant(Constant::Int(val.into()), Pos::ZERO),
            Instr::I64Const(val) => Expr::Constant(Constant::Int(val.into()), Pos::ZERO),
            Instr::U8Const(val) => Expr::Constant(Constant::Uint(val.into()), Pos::ZERO),
            Instr::U16Const(val) => Expr::Constant(Constant::Uint(val.into()), Pos::ZERO),
            Instr::U32Const(val) => Expr::Constant(Constant::Uint(val.into()), Pos::ZERO),
            Instr::U64Const(val) => Expr::Constant(Constant::Uint(val.into()), Pos::ZERO),
            Instr::F32Const(val) => Expr::Constant(Constant::Float(val.into()), Pos::ZERO),
            Instr::F64Const(val) => Expr::Constant(Constant::Float(val.into()), Pos::ZERO),
            Instr::StringConst(str) => {
                let decoded = String::from_utf8(str).unwrap();
                Expr::Constant(Constant::String(LiteralType::String, decoded), Pos::ZERO)
            }
            Instr::NameConst(idx) => {
                let str = self.pool.names.get(idx)?.deref().clone();
                Expr::Constant(Constant::String(LiteralType::Name, str), Pos::ZERO)
            }
            Instr::TweakDbIdConst(idx) => {
                let str = self.pool.tweakdb_ids.get(idx)?.deref().clone();
                Expr::Constant(Constant::String(LiteralType::TweakDbId, str), Pos::ZERO)
            }
            Instr::ResourceConst(idx) => {
                let str = self.pool.resources.get(idx)?.deref().clone();
                Expr::Constant(Constant::String(LiteralType::Resource, str), Pos::ZERO)
            }
            Instr::TrueConst => Expr::Constant(Constant::Bool(true), Pos::ZERO),
            Instr::FalseConst => Expr::Constant(Constant::Bool(false), Pos::ZERO),
            Instr::EnumConst(enum_, member) => {
                let enum_ident = self.definition_ident(enum_)?;
                let member_ident = self.definition_ident(member)?;
                let expr = Box::new(Expr::Ident(enum_ident, Pos::ZERO));
                Expr::Member(expr, member_ident, Pos::ZERO)
            }
            Instr::Breakpoint(_, _, _, _, _, _) => Err(Error::DecompileError("Unexpected Breakpoint".to_owned()))?,
            Instr::Assign => {
                let lhs = self.consume()?;
                let rhs = self.consume()?;
                Expr::Assign(Box::new(lhs), Box::new(rhs), Pos::ZERO)
            }
            Instr::Target => Err(Error::DecompileError("Unexpected Target".to_owned()))?,
            Instr::Local(idx) => Expr::Ident(self.definition_ident(idx)?, Pos::ZERO),
            Instr::Param(idx) => Expr::Ident(self.definition_ident(idx)?, Pos::ZERO),
            Instr::ObjectField(idx) => {
                let field = self.definition_ident(idx)?;
                if let Some(object) = context {
                    Expr::Member(Box::new(object), field, Pos::ZERO)
                } else {
                    Expr::Member(Box::new(Expr::This(Pos::ZERO)), field, Pos::ZERO)
                }
            }
            Instr::ExternalVar => Err(Error::DecompileError("Unexpected ExternalVar".to_owned()))?,
            Instr::Switch(_, _) => self.consume_switch()?,
            Instr::SwitchLabel(_, _) => Err(Error::DecompileError("Unexpected SwitchLabel".to_owned()))?,
            Instr::SwitchDefault => Err(Error::DecompileError("Unexpected SwitchDefault".to_owned()))?,
            Instr::Jump(Offset { value: 3 }) => Expr::EMPTY,
            Instr::Jump(offset) => Expr::Goto(Target::new(offset.absolute(position).value), Pos::ZERO),
            Instr::JumpIfFalse(offset) => {
                assert!(offset.value >= 0, "negative offset is not supported for JumpIfFalse");
                self.consume_conditional_jump(position, offset)?
            }
            Instr::Skip(offset) => Expr::Goto(Target::new(offset.absolute(position).value), Pos::ZERO),
            Instr::Conditional(_, _) => {
                let expr = self.consume()?;
                let true_case = self.consume()?;
                let false_case = self.consume()?;
                Expr::Conditional(Box::new(expr), Box::new(true_case), Box::new(false_case), Pos::ZERO)
            }
            Instr::Construct(n, class) => {
                let params = self.consume_n(n.into())?;
                Expr::New(Ident(self.pool.definition_name(class)?), params, Pos::ZERO)
            }
            Instr::InvokeStatic(_, _, idx) => {
                let def = self.pool.definition(idx)?;
                let name = Ident(self.pool.names.get(def.name)?);
                let params = self.consume_params()?;
                if let Some(ctx) = context {
                    Expr::MethodCall(Box::new(ctx), name, params, Pos::ZERO)
                } else if self.pool.function(idx)?.flags.is_static() {
                    if def.parent.is_undefined() {
                        Expr::Call(name, params, Pos::ZERO)
                    } else {
                        let class_name = Ident(self.pool.definition_name(def.parent)?);
                        let expr = Box::new(Expr::Ident(class_name, Pos::ZERO));
                        Expr::MethodCall(expr, name, params, Pos::ZERO)
                    }
                } else {
                    Expr::MethodCall(Box::new(Expr::This(Pos::ZERO)), name, params, Pos::ZERO)
                }
                // if let AnyDefinition::Function(ref fun) = def.value {
                // assert_eq!(fun.parameters.len(), params.len(), "Invalid number of parameters {:?}", params);
                // }
            }
            Instr::InvokeVirtual(_, _, idx) => {
                let name = Ident(self.pool.names.get(idx)?);
                let params = self.consume_params()?;
                if let Some(ctx) = context {
                    Expr::MethodCall(Box::new(ctx), name, params, Pos::ZERO)
                } else {
                    Expr::MethodCall(Box::new(Expr::This(Pos::ZERO)), name, params, Pos::ZERO)
                }
            }
            Instr::ParamEnd => Err(Error::DecompileError("Unexpected ParamEnd".to_owned()))?,
            Instr::Return => Expr::Return(self.consume().ok().map(|e| Box::new(e)), Pos::ZERO),
            Instr::StructField(idx) => {
                let target = self.consume()?;
                let field = self.definition_ident(idx)?;
                Expr::Member(Box::new(target), field, Pos::ZERO)
            }
            Instr::Context(_) => {
                let expr = self.consume()?;
                self.consume_with(Some(expr))?
            }
            Instr::Equals(_) => self.consume_call("Equals", 2)?,
            Instr::NotEquals(_) => self.consume_call("NotEquals", 2)?,
            Instr::New(class) => Expr::New(Ident(self.pool.definition_name(class)?), vec![], Pos::ZERO),
            Instr::Delete => self.consume_call("Delete", 1)?,
            Instr::This => Expr::This(Pos::ZERO),
            Instr::StartProfiling(_, _) => Err(Error::DecompileError("Unexpected StartProfiling".to_owned()))?,
            Instr::ArrayClear(_) => self.consume_call("ArrayClear", 1)?,
            Instr::ArraySize(_) => self.consume_call("ArraySize", 1)?,
            Instr::ArrayResize(_) => self.consume_call("ArrayResize", 2)?,
            Instr::ArrayFindFirst(_) => self.consume_call("ArrayFindFirst", 2)?,
            Instr::ArrayFindFirstFast(_) => self.consume_call("ArrayFindFirst", 2)?,
            Instr::ArrayFindLast(_) => self.consume_call("ArrayFindLast", 2)?,
            Instr::ArrayFindLastFast(_) => self.consume_call("ArrayFindLast", 2)?,
            Instr::ArrayContains(_) => self.consume_call("ArrayContains", 2)?,
            Instr::ArrayContainsFast(_) => self.consume_call("ArrayContains", 2)?,
            Instr::ArrayCount(_) => self.consume_call("ArrayCount", 2)?,
            Instr::ArrayCountFast(_) => self.consume_call("ArrayCount", 2)?,
            Instr::ArrayPush(_) => self.consume_call("ArrayPush", 2)?,
            Instr::ArrayPop(_) => self.consume_call("ArrayPop", 1)?,
            Instr::ArrayInsert(_) => self.consume_call("ArrayInsert", 3)?,
            Instr::ArrayRemove(_) => self.consume_call("ArrayRemove", 2)?,
            Instr::ArrayRemoveFast(_) => self.consume_call("ArrayRemove", 2)?,
            Instr::ArrayGrow(_) => self.consume_call("ArrayGrow", 2)?,
            Instr::ArrayErase(_) => self.consume_call("ArrayErase", 2)?,
            Instr::ArrayEraseFast(_) => self.consume_call("ArrayErase", 2)?,
            Instr::ArrayLast(_) => self.consume_call("ArrayLast", 1)?,
            Instr::ArrayElement(_) => {
                let arr = self.consume()?;
                let idx = self.consume()?;
                Expr::ArrayElem(Box::new(arr), Box::new(idx), Pos::ZERO)
            }
            Instr::StaticArraySize(_) => self.consume_call("StaticArraySize", 1)?,
            Instr::StaticArrayFindFirst(_) => self.consume_call("StaticArrayFindFirst", 2)?,
            Instr::StaticArrayFindFirstFast(_) => self.consume_call("StaticArrayFindFirstFast", 2)?,
            Instr::StaticArrayFindLast(_) => self.consume_call("StaticArrayFindLast", 2)?,
            Instr::StaticArrayFindLastFast(_) => self.consume_call("StaticArrayFindLastFast", 2)?,
            Instr::StaticArrayContains(_) => self.consume_call("StaticArrayContains", 2)?,
            Instr::StaticArrayContainsFast(_) => self.consume_call("StaticArrayContainsFast", 2)?,
            Instr::StaticArrayCount(_) => self.consume_call("StaticArrayCount", 2)?,
            Instr::StaticArrayCountFast(_) => self.consume_call("StaticArrayCountFast", 2)?,
            Instr::StaticArrayLast(_) => self.consume_call("StaticArrayLast", 1)?,
            Instr::StaticArrayElement(_) => {
                let arr = self.consume()?;
                let idx = self.consume()?;
                Expr::ArrayElem(Box::new(arr), Box::new(idx), Pos::ZERO)
            }
            Instr::RefToBool => self.consume_call("RefToBool", 1)?,
            Instr::WeakRefToBool => self.consume_call("WeakRefToBool", 1)?,
            Instr::EnumToI32(_, _) => self.consume_call("EnumInt", 1)?,
            Instr::I32ToEnum(_, _) => self.consume_call("IntEnum", 1)?,
            Instr::DynamicCast(type_, _) => {
                let name = self.pool.definition_name(type_)?;
                let type_name = TypeName {
                    name: name.deref().to_owned(),
                    arguments: vec![],
                };
                let expr = self.consume()?;
                Expr::Cast(type_name, Box::new(expr), Pos::ZERO)
            }
            Instr::ToString(_) => self.consume_call("ToString", 1)?,
            Instr::ToVariant(_) => self.consume_call("ToVariant", 1)?,
            Instr::FromVariant(_) => self.consume_call("FromVariant", 1)?,
            Instr::VariantIsValid => self.consume_call("IsValid", 1)?,
            Instr::VariantIsRef => self.consume_call("IsRef", 1)?,
            Instr::VariantIsArray => self.consume_call("IsArray", 1)?,
            Instr::VatiantToCName => self.consume_call("ToCName", 1)?,
            Instr::VariantToString => self.consume_call("ToString", 1)?,
            Instr::WeakRefToRef => self.consume_call("WeakRefToRef", 1)?,
            Instr::RefToWeakRef => self.consume_call("RefToWeakRef", 1)?,
            Instr::WeakRefNull => Expr::Null,
            Instr::AsRef(_) => self.consume_call("AsRef", 1)?,
            Instr::Deref(_) => self.consume_call("Deref", 1)?,
        };
        Ok(res)
    }
}

fn resolve_jump(seq: &mut Seq, target: Option<Position>) -> Option<&mut Target> {
    seq.exprs.iter_mut().rev().find_map(|expr| match expr {
        Expr::Goto(goto, _) if !goto.resolved && target.map(|target| goto.position == target.value).unwrap_or(true) => {
            goto.resolved = true;
            Some(goto)
        }
        Expr::If(_, if_, None) => resolve_jump(if_, target),
        Expr::If(_, if_, Some(else_)) => resolve_jump(if_, target).or(resolve_jump(else_, target)),
        _ => None,
    })
}
